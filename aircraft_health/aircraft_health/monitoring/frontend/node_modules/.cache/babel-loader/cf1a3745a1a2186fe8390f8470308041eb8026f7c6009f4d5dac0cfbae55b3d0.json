{"ast":null,"code":"import { memo as e, useMemo as o, useState as i, useCallback as t, createElement as n, Fragment as r, forwardRef as a, useRef as l, useEffect as s } from \"react\";\nimport { useTheme as d, curveFromProp as c, useValueFormatter as u, useMotionConfig as h, useAnimatedPath as f, getLabelGenerator as v, DotsItem as p, withContainer as m, useDimensions as g, CartesianMarkers as y, bindDefs as x, SvgWrapper as b, ResponsiveWrapper as S, getRelativeCursor as M, isCursorInRect as C } from \"@nivo/core\";\nimport { useOrdinalColorScale as w, useInheritedColor as T } from \"@nivo/colors\";\nimport { Grid as k, Axes as B, renderGridLinesToCanvas as W, renderAxesToCanvas as E } from \"@nivo/axes\";\nimport { BoxLegendSvg as L, renderLegendToCanvas as G } from \"@nivo/legends\";\nimport { BasicTooltip as P, TableTooltip as F, Chip as O, useTooltip as V, Crosshair as I } from \"@nivo/tooltip\";\nimport { line as H, area as Y } from \"d3-shape\";\nimport { computeXYScalesForSeries as R } from \"@nivo/scales\";\nimport A from \"lodash/uniqueId\";\nimport { jsx as X, jsxs as z } from \"react/jsx-runtime\";\nimport { useSpring as j, animated as D } from \"@react-spring/web\";\nimport { Mesh as q, useVoronoiMesh as J, renderVoronoiToCanvas as K, renderVoronoiCellToCanvas as N } from \"@nivo/voronoi\";\nfunction Q() {\n  return Q = Object.assign ? Object.assign.bind() : function (e) {\n    for (var o = 1; o < arguments.length; o++) {\n      var i = arguments[o];\n      for (var t in i) Object.prototype.hasOwnProperty.call(i, t) && (e[t] = i[t]);\n    }\n    return e;\n  }, Q.apply(this, arguments);\n}\nvar U = e(function (e) {\n    var o = e.point;\n    return X(P, {\n      id: z(\"span\", {\n        children: [\"x: \", X(\"strong\", {\n          children: o.data.xFormatted\n        }), \", y:\", \" \", X(\"strong\", {\n          children: o.data.yFormatted\n        })]\n      }),\n      enableChip: !0,\n      color: o.serieColor\n    });\n  }),\n  Z = e(function (e) {\n    var o = e.slice,\n      i = e.axis,\n      t = d(),\n      n = \"x\" === i ? \"y\" : \"x\";\n    return X(F, {\n      rows: o.points.map(function (e) {\n        return [X(O, {\n          color: e.serieColor,\n          style: t.tooltip.chip\n        }, \"chip\"), e.serieId, X(\"span\", {\n          style: t.tooltip.tableCellValue,\n          children: e.data[n + \"Formatted\"]\n        }, \"value\")];\n      })\n    });\n  }),\n  $ = {\n    curve: \"linear\",\n    xScale: {\n      type: \"point\"\n    },\n    yScale: {\n      type: \"linear\",\n      min: 0,\n      max: \"auto\"\n    },\n    layers: [\"grid\", \"markers\", \"axes\", \"areas\", \"crosshair\", \"lines\", \"points\", \"slices\", \"mesh\", \"legends\"],\n    axisBottom: {},\n    axisLeft: {},\n    enableGridX: !0,\n    enableGridY: !0,\n    enablePoints: !0,\n    pointSize: 6,\n    pointColor: {\n      from: \"color\"\n    },\n    pointBorderWidth: 0,\n    pointBorderColor: {\n      theme: \"background\"\n    },\n    enablePointLabel: !1,\n    pointLabel: \"yFormatted\",\n    colors: {\n      scheme: \"nivo\"\n    },\n    enableArea: !1,\n    areaBaselineValue: 0,\n    areaOpacity: .2,\n    areaBlendMode: \"normal\",\n    lineWidth: 2,\n    legends: [],\n    isInteractive: !0,\n    tooltip: U,\n    enableSlices: !1,\n    debugSlices: !1,\n    sliceTooltip: Z,\n    debugMesh: !1,\n    enableCrosshair: !0,\n    crosshairType: \"bottom-left\"\n  },\n  _ = Q({}, $, {\n    enablePointLabel: !1,\n    useMesh: !1,\n    enableTouchCrosshair: !1,\n    animate: !0,\n    motionConfig: \"gentle\",\n    defs: [],\n    fill: [],\n    role: \"img\",\n    initialHiddenIds: []\n  }),\n  ee = Q({}, $, {\n    pixelRatio: \"undefined\" != typeof window && window.devicePixelRatio || 1\n  }),\n  oe = function (e) {\n    var i = e.curve;\n    return o(function () {\n      return H().defined(function (e) {\n        return null !== e.x && null !== e.y;\n      }).x(function (e) {\n        return e.x;\n      }).y(function (e) {\n        return e.y;\n      }).curve(c(i));\n    }, [i]);\n  },\n  ie = function (e) {\n    var i = e.curve,\n      t = e.yScale,\n      n = e.areaBaselineValue;\n    return o(function () {\n      return Y().defined(function (e) {\n        return null !== e.x && null !== e.y;\n      }).x(function (e) {\n        return e.x;\n      }).y1(function (e) {\n        return e.y;\n      }).curve(c(i)).y0(t(n));\n    }, [i, t, n]);\n  },\n  te = function (e) {\n    var i = e.componentId,\n      t = e.enableSlices,\n      n = e.points,\n      r = e.width,\n      a = e.height;\n    return o(function () {\n      if (!1 === t) return [];\n      if (\"x\" === t) {\n        var e = new Map();\n        return n.forEach(function (o) {\n          null !== o.data.x && null !== o.data.y && (e.has(o.x) ? e.get(o.x).push(o) : e.set(o.x, [o]));\n        }), Array.from(e.entries()).sort(function (e, o) {\n          return e[0] - o[0];\n        }).map(function (e, o, t) {\n          var n,\n            l,\n            s = e[0],\n            d = e[1],\n            c = t[o - 1],\n            u = t[o + 1];\n          return n = c ? s - (s - c[0]) / 2 : s, l = u ? s - n + (u[0] - s) / 2 : r - n, {\n            id: \"slice:\" + i + \":\" + s,\n            x0: n,\n            x: s,\n            y0: 0,\n            y: 0,\n            width: l,\n            height: a,\n            points: d.reverse()\n          };\n        });\n      }\n      if (\"y\" === t) {\n        var o = new Map();\n        return n.forEach(function (e) {\n          null !== e.data.x && null !== e.data.y && (o.has(e.y) ? o.get(e.y).push(e) : o.set(e.y, [e]));\n        }), Array.from(o.entries()).sort(function (e, o) {\n          return e[0] - o[0];\n        }).map(function (e, o, i) {\n          var t,\n            n,\n            l = e[0],\n            s = e[1],\n            d = i[o - 1],\n            c = i[o + 1];\n          return t = d ? l - (l - d[0]) / 2 : l, n = c ? l - t + (c[0] - l) / 2 : a - t, {\n            id: l,\n            x0: 0,\n            x: 0,\n            y0: t,\n            y: l,\n            width: r,\n            height: n,\n            points: s.reverse()\n          };\n        });\n      }\n    }, [i, t, a, n, r]);\n  },\n  ne = \"line\",\n  re = function (e) {\n    var n = e.data,\n      r = e.xScale,\n      a = void 0 === r ? _.xScale : r,\n      l = e.xFormat,\n      s = e.yScale,\n      c = void 0 === s ? _.yScale : s,\n      h = e.yFormat,\n      f = e.width,\n      v = e.height,\n      p = e.colors,\n      m = void 0 === p ? _.colors : p,\n      g = e.curve,\n      y = void 0 === g ? _.curve : g,\n      x = e.areaBaselineValue,\n      b = void 0 === x ? _.areaBaselineValue : x,\n      S = e.pointColor,\n      M = void 0 === S ? _.pointColor : S,\n      C = e.pointBorderColor,\n      k = void 0 === C ? _.pointBorderColor : C,\n      B = e.enableSlices,\n      W = void 0 === B ? _.enableSlicesTooltip : B,\n      E = e.initialHiddenIds,\n      L = void 0 === E ? _.initialHiddenIds : E,\n      G = i(A(ne))[0],\n      P = u(l),\n      F = u(h),\n      O = w(m, \"id\"),\n      V = d(),\n      I = T(M, V),\n      H = T(k, V),\n      Y = i(null != L ? L : []),\n      X = Y[0],\n      z = Y[1],\n      j = o(function () {\n        return R(n.filter(function (e) {\n          return -1 === X.indexOf(e.id);\n        }), a, c, f, v);\n      }, [n, X, a, c, f, v]),\n      D = j.xScale,\n      q = j.yScale,\n      J = j.series,\n      K = o(function () {\n        var e = n.map(function (e) {\n            return {\n              id: e.id,\n              label: e.id,\n              color: O(e)\n            };\n          }),\n          o = e.map(function (e) {\n            return Q({}, J.find(function (o) {\n              return o.id === e.id;\n            }), {\n              color: e.color\n            });\n          }).filter(function (e) {\n            return Boolean(e.id);\n          });\n        return {\n          legendData: e.map(function (e) {\n            return Q({}, e, {\n              hidden: !o.find(function (o) {\n                return o.id === e.id;\n              })\n            });\n          }).reverse(),\n          series: o\n        };\n      }, [n, J, O]),\n      N = K.legendData,\n      U = K.series,\n      Z = t(function (e) {\n        z(function (o) {\n          return o.indexOf(e) > -1 ? o.filter(function (o) {\n            return o !== e;\n          }) : [].concat(o, [e]);\n        });\n      }, []),\n      $ = function (e) {\n        var i = e.series,\n          t = e.getPointColor,\n          n = e.getPointBorderColor,\n          r = e.formatX,\n          a = e.formatY;\n        return o(function () {\n          return i.reduce(function (e, o) {\n            return [].concat(e, o.data.filter(function (e) {\n              return null !== e.position.x && null !== e.position.y;\n            }).map(function (i, l) {\n              var s = {\n                id: o.id + \".\" + l,\n                index: e.length + l,\n                serieId: o.id,\n                serieColor: o.color,\n                x: i.position.x,\n                y: i.position.y\n              };\n              return s.color = t(o), s.borderColor = n(s), s.data = Q({}, i.data, {\n                xFormatted: r(i.data.x),\n                yFormatted: a(i.data.y)\n              }), s;\n            }));\n          }, []);\n        }, [i, t, n, r, a]);\n      }({\n        series: U,\n        getPointColor: I,\n        getPointBorderColor: H,\n        formatX: P,\n        formatY: F\n      }),\n      ee = te({\n        componentId: G,\n        enableSlices: W,\n        points: $,\n        width: f,\n        height: v\n      });\n    return {\n      legendData: N,\n      toggleSerie: Z,\n      lineGenerator: oe({\n        curve: y\n      }),\n      areaGenerator: ie({\n        curve: y,\n        yScale: q,\n        areaBaselineValue: b\n      }),\n      getColor: O,\n      series: U,\n      xScale: D,\n      yScale: q,\n      slices: ee,\n      points: $\n    };\n  },\n  ae = function (e) {\n    var o = e.areaBlendMode,\n      i = e.areaOpacity,\n      t = e.color,\n      n = e.fill,\n      r = e.path,\n      a = h(),\n      l = a.animate,\n      s = a.config,\n      d = f(r),\n      c = j({\n        color: t,\n        config: s,\n        immediate: !l\n      });\n    return X(D.path, {\n      d: d,\n      fill: n || c.color,\n      fillOpacity: i,\n      strokeWidth: 0,\n      style: {\n        mixBlendMode: o\n      }\n    });\n  },\n  le = e(function (e) {\n    var o = e.areaGenerator,\n      i = e.areaOpacity,\n      t = e.areaBlendMode,\n      n = e.lines.slice(0).reverse();\n    return X(\"g\", {\n      children: n.map(function (e) {\n        return X(ae, Q({\n          path: o(e.data.map(function (e) {\n            return e.position;\n          }))\n        }, Q({\n          areaOpacity: i,\n          areaBlendMode: t\n        }, e)), e.id);\n      })\n    });\n  }),\n  se = e(function (e) {\n    var i = e.lineGenerator,\n      t = e.points,\n      n = e.color,\n      r = e.thickness,\n      a = o(function () {\n        return i(t);\n      }, [i, t]),\n      l = f(a);\n    return X(D.path, {\n      d: l,\n      fill: \"none\",\n      strokeWidth: r,\n      stroke: n\n    });\n  }),\n  de = e(function (e) {\n    var o = e.lines,\n      i = e.lineGenerator,\n      t = e.lineWidth;\n    return o.slice(0).reverse().map(function (e) {\n      var o = e.id,\n        n = e.data,\n        r = e.color;\n      return X(se, {\n        id: o,\n        points: n.map(function (e) {\n          return e.position;\n        }),\n        lineGenerator: i,\n        color: r,\n        thickness: t\n      }, o);\n    });\n  }),\n  ce = e(function (e) {\n    var o = e.slice,\n      i = e.slices,\n      r = e.axis,\n      a = e.debug,\n      l = e.tooltip,\n      s = e.isCurrent,\n      d = e.setCurrent,\n      c = e.onMouseEnter,\n      u = e.onMouseMove,\n      h = e.onMouseLeave,\n      f = e.onClick,\n      v = e.onTouchStart,\n      p = e.onTouchMove,\n      m = e.onTouchEnd,\n      g = V(),\n      y = g.showTooltipFromEvent,\n      x = g.hideTooltip,\n      b = t(function (e) {\n        y(n(l, {\n          slice: o,\n          axis: r\n        }), e, \"right\"), d(o), c && c(o, e);\n      }, [y, l, o, r, d, c]),\n      S = t(function (e) {\n        y(n(l, {\n          slice: o,\n          axis: r\n        }), e, \"right\"), u && u(o, e);\n      }, [y, l, o, r, u]),\n      M = t(function (e) {\n        x(), d(null), h && h(o, e);\n      }, [x, d, h, o]),\n      C = t(function (e) {\n        f && f(o, e);\n      }, [o, f]),\n      w = t(function (e) {\n        y(n(l, {\n          slice: o,\n          axis: r\n        }), e, \"right\"), d(o), v && v(o, e);\n      }, [r, v, d, y, o, l]),\n      T = t(function (e) {\n        var t = e.touches[0],\n          a = document.elementFromPoint(t.clientX, t.clientY),\n          s = null == a ? void 0 : a.getAttribute(\"data-ref\");\n        if (s) {\n          var c = i.find(function (e) {\n            return e.id === s;\n          });\n          c && (y(n(l, {\n            slice: c,\n            axis: r\n          }), e, \"right\"), d(c));\n        }\n        p && p(o, e);\n      }, [r, p, d, y, o, i, l]),\n      k = t(function (e) {\n        x(), d(null), m && m(o, e);\n      }, [x, d, m, o]);\n    return X(\"rect\", {\n      x: o.x0,\n      y: o.y0,\n      width: o.width,\n      height: o.height,\n      stroke: \"red\",\n      strokeWidth: a ? 1 : 0,\n      strokeOpacity: .75,\n      fill: \"red\",\n      fillOpacity: s && a ? .35 : 0,\n      onMouseEnter: b,\n      onMouseMove: S,\n      onMouseLeave: M,\n      onClick: C,\n      onTouchStart: w,\n      onTouchMove: T,\n      onTouchEnd: k,\n      \"data-ref\": o.id\n    });\n  }),\n  ue = e(function (e) {\n    var o = e.slices,\n      i = e.axis,\n      t = e.debug,\n      n = e.height,\n      r = e.tooltip,\n      a = e.current,\n      l = e.setCurrent,\n      s = e.onMouseEnter,\n      d = e.onMouseMove,\n      c = e.onMouseLeave,\n      u = e.onClick,\n      h = e.onTouchStart,\n      f = e.onTouchMove,\n      v = e.onTouchEnd;\n    return o.map(function (e) {\n      return X(ce, {\n        slice: e,\n        slices: o,\n        axis: i,\n        debug: t,\n        height: n,\n        tooltip: r,\n        setCurrent: l,\n        isCurrent: null !== a && a.id === e.id,\n        onMouseEnter: s,\n        onMouseMove: d,\n        onMouseLeave: c,\n        onClick: u,\n        onTouchStart: h,\n        onTouchMove: f,\n        onTouchEnd: v\n      }, e.id);\n    });\n  }),\n  he = e(function (e) {\n    var o = e.points,\n      i = e.symbol,\n      t = e.size,\n      n = e.borderWidth,\n      r = e.enableLabel,\n      a = e.label,\n      l = e.labelYOffset,\n      s = d(),\n      c = v(a),\n      u = o.slice(0).reverse().map(function (e) {\n        return {\n          id: e.id,\n          x: e.x,\n          y: e.y,\n          datum: e.data,\n          fill: e.color,\n          stroke: e.borderColor,\n          label: r ? c(e) : null\n        };\n      });\n    return X(\"g\", {\n      children: u.map(function (e) {\n        return X(p, {\n          x: e.x,\n          y: e.y,\n          datum: e.datum,\n          symbol: i,\n          size: t,\n          color: e.fill,\n          borderWidth: n,\n          borderColor: e.stroke,\n          label: e.label,\n          labelYOffset: l,\n          theme: s\n        }, e.id);\n      })\n    });\n  }),\n  fe = e(function (e) {\n    var o = e.points,\n      i = e.width,\n      r = e.height,\n      a = e.margin,\n      l = e.setCurrent,\n      s = e.onMouseEnter,\n      d = e.onMouseMove,\n      c = e.onMouseLeave,\n      u = e.onClick,\n      h = e.onTouchStart,\n      f = e.onTouchMove,\n      v = e.onTouchEnd,\n      p = e.tooltip,\n      m = e.debug,\n      g = e.enableTouchCrosshair,\n      y = V(),\n      x = y.showTooltipAt,\n      b = y.hideTooltip,\n      S = t(function (e, o) {\n        x(n(p, {\n          point: e\n        }), [e.x + a.left, e.y + a.top], \"top\"), s && s(e, o);\n      }, [x, p, s, a]),\n      M = t(function (e, o) {\n        x(n(p, {\n          point: e\n        }), [e.x + a.left, e.y + a.top], \"top\"), d && d(e, o);\n      }, [x, p, a.left, a.top, d]),\n      C = t(function (e, o) {\n        b(), c && c(e, o);\n      }, [b, c]),\n      w = t(function (e, o) {\n        u && u(e, o);\n      }, [u]),\n      T = t(function (e, o) {\n        x(n(p, {\n          point: e\n        }), [e.x + a.left, e.y + a.top], \"top\"), h && h(e, o);\n      }, [a.left, a.top, h, x, p]),\n      k = t(function (e, o) {\n        x(n(p, {\n          point: e\n        }), [e.x + a.left, e.y + a.top], \"top\"), f && f(e, o);\n      }, [a.left, a.top, f, x, p]),\n      B = t(function (e, o) {\n        b(), v && v(e, o);\n      }, [v, b]);\n    return X(q, {\n      nodes: o,\n      width: i,\n      height: r,\n      setCurrent: l,\n      onMouseEnter: S,\n      onMouseMove: M,\n      onMouseLeave: C,\n      onClick: w,\n      onTouchStart: T,\n      onTouchMove: k,\n      onTouchEnd: B,\n      enableTouchCrosshair: g,\n      debug: m\n    });\n  }),\n  ve = m(function (e) {\n    var o = e.data,\n      t = e.xScale,\n      n = void 0 === t ? {\n        type: \"point\"\n      } : t,\n      a = e.xFormat,\n      l = e.yScale,\n      s = void 0 === l ? {\n        type: \"linear\",\n        min: 0,\n        max: \"auto\"\n      } : l,\n      c = e.yFormat,\n      u = e.layers,\n      h = void 0 === u ? [\"grid\", \"markers\", \"axes\", \"areas\", \"crosshair\", \"lines\", \"points\", \"slices\", \"mesh\", \"legends\"] : u,\n      f = e.curve,\n      v = void 0 === f ? \"linear\" : f,\n      p = e.areaBaselineValue,\n      m = void 0 === p ? 0 : p,\n      S = e.colors,\n      M = void 0 === S ? {\n        scheme: \"nivo\"\n      } : S,\n      C = e.margin,\n      w = e.width,\n      W = e.height,\n      E = e.axisTop,\n      G = e.axisRight,\n      P = e.axisBottom,\n      F = void 0 === P ? {} : P,\n      O = e.axisLeft,\n      V = void 0 === O ? {} : O,\n      H = e.enableGridX,\n      Y = void 0 === H || H,\n      R = e.enableGridY,\n      A = void 0 === R || R,\n      z = e.gridXValues,\n      j = e.gridYValues,\n      D = e.lineWidth,\n      q = void 0 === D ? 2 : D,\n      J = e.enableArea,\n      K = void 0 !== J && J,\n      N = e.areaOpacity,\n      $ = void 0 === N ? .2 : N,\n      _ = e.areaBlendMode,\n      ee = void 0 === _ ? \"normal\" : _,\n      oe = e.enablePoints,\n      ie = void 0 === oe || oe,\n      te = e.pointSymbol,\n      ne = e.pointSize,\n      ae = void 0 === ne ? 6 : ne,\n      se = e.pointColor,\n      ce = void 0 === se ? {\n        from: \"color\"\n      } : se,\n      ve = e.pointBorderWidth,\n      pe = void 0 === ve ? 0 : ve,\n      me = e.pointBorderColor,\n      ge = void 0 === me ? {\n        theme: \"background\"\n      } : me,\n      ye = e.enablePointLabel,\n      xe = void 0 !== ye && ye,\n      be = e.pointLabel,\n      Se = void 0 === be ? \"data.yFormatted\" : be,\n      Me = e.pointLabelYOffset,\n      Ce = e.defs,\n      we = void 0 === Ce ? [] : Ce,\n      Te = e.fill,\n      ke = void 0 === Te ? [] : Te,\n      Be = e.markers,\n      We = e.legends,\n      Ee = void 0 === We ? [] : We,\n      Le = e.isInteractive,\n      Ge = void 0 === Le || Le,\n      Pe = e.useMesh,\n      Fe = void 0 !== Pe && Pe,\n      Oe = e.debugMesh,\n      Ve = void 0 !== Oe && Oe,\n      Ie = e.onMouseEnter,\n      He = e.onMouseMove,\n      Ye = e.onMouseLeave,\n      Re = e.onClick,\n      Ae = e.onTouchStart,\n      Xe = e.onTouchMove,\n      ze = e.onTouchEnd,\n      je = e.tooltip,\n      De = void 0 === je ? U : je,\n      qe = e.enableSlices,\n      Je = void 0 !== qe && qe,\n      Ke = e.debugSlices,\n      Ne = void 0 !== Ke && Ke,\n      Qe = e.sliceTooltip,\n      Ue = void 0 === Qe ? Z : Qe,\n      Ze = e.enableCrosshair,\n      $e = void 0 === Ze || Ze,\n      _e = e.crosshairType,\n      eo = void 0 === _e ? \"bottom-left\" : _e,\n      oo = e.enableTouchCrosshair,\n      io = void 0 !== oo && oo,\n      to = e.role,\n      no = void 0 === to ? \"img\" : to,\n      ro = e.initialHiddenIds,\n      ao = void 0 === ro ? [] : ro,\n      lo = g(w, W, C),\n      so = lo.margin,\n      co = lo.innerWidth,\n      uo = lo.innerHeight,\n      ho = lo.outerWidth,\n      fo = lo.outerHeight,\n      vo = re({\n        data: o,\n        xScale: n,\n        xFormat: a,\n        yScale: s,\n        yFormat: c,\n        width: co,\n        height: uo,\n        colors: M,\n        curve: v,\n        areaBaselineValue: m,\n        pointColor: ce,\n        pointBorderColor: ge,\n        enableSlices: Je,\n        initialHiddenIds: ao\n      }),\n      po = vo.legendData,\n      mo = vo.toggleSerie,\n      go = vo.lineGenerator,\n      yo = vo.areaGenerator,\n      xo = vo.series,\n      bo = vo.xScale,\n      So = vo.yScale,\n      Mo = vo.slices,\n      Co = vo.points,\n      wo = d(),\n      To = T(ce, wo),\n      ko = T(ge, wo),\n      Bo = i(null),\n      Wo = Bo[0],\n      Eo = Bo[1],\n      Lo = i(null),\n      Go = Lo[0],\n      Po = Lo[1],\n      Fo = {\n        grid: X(k, {\n          theme: wo,\n          width: co,\n          height: uo,\n          xScale: Y ? bo : null,\n          yScale: A ? So : null,\n          xValues: z,\n          yValues: j\n        }, \"grid\"),\n        markers: X(y, {\n          markers: Be,\n          width: co,\n          height: uo,\n          xScale: bo,\n          yScale: So,\n          theme: wo\n        }, \"markers\"),\n        axes: X(B, {\n          xScale: bo,\n          yScale: So,\n          width: co,\n          height: uo,\n          theme: wo,\n          top: E,\n          right: G,\n          bottom: F,\n          left: V\n        }, \"axes\"),\n        areas: null,\n        lines: X(de, {\n          lines: xo,\n          lineGenerator: go,\n          lineWidth: q\n        }, \"lines\"),\n        slices: null,\n        points: null,\n        crosshair: null,\n        mesh: null,\n        legends: Ee.map(function (e, o) {\n          return X(L, Q({}, e, {\n            containerWidth: co,\n            containerHeight: uo,\n            data: e.data || po,\n            theme: wo,\n            toggleSerie: e.toggleSerie ? mo : void 0\n          }), \"legend.\" + o);\n        })\n      },\n      Oo = x(we, xo, ke);\n    return K && (Fo.areas = X(le, {\n      areaGenerator: yo,\n      areaOpacity: $,\n      areaBlendMode: ee,\n      lines: xo\n    }, \"areas\")), Ge && !1 !== Je && (Fo.slices = X(ue, {\n      slices: Mo,\n      axis: Je,\n      debug: Ne,\n      height: uo,\n      tooltip: Ue,\n      current: Go,\n      setCurrent: Po,\n      onMouseEnter: Ie,\n      onMouseMove: He,\n      onMouseLeave: Ye,\n      onClick: Re,\n      onTouchStart: Ae,\n      onTouchMove: Xe,\n      onTouchEnd: ze\n    }, \"slices\")), ie && (Fo.points = X(he, {\n      points: Co,\n      symbol: te,\n      size: ae,\n      color: To,\n      borderWidth: pe,\n      borderColor: ko,\n      enableLabel: xe,\n      label: Se,\n      labelYOffset: Me\n    }, \"points\")), Ge && $e && (null !== Wo && (Fo.crosshair = X(I, {\n      width: co,\n      height: uo,\n      x: Wo.x,\n      y: Wo.y,\n      type: eo\n    }, \"crosshair\")), null !== Go && (Fo.crosshair = X(I, {\n      width: co,\n      height: uo,\n      x: Go.x,\n      y: Go.y,\n      type: Je\n    }, \"crosshair\"))), Ge && Fe && !1 === Je && (Fo.mesh = X(fe, {\n      points: Co,\n      width: co,\n      height: uo,\n      margin: so,\n      current: Wo,\n      setCurrent: Eo,\n      onMouseEnter: Ie,\n      onMouseMove: He,\n      onMouseLeave: Ye,\n      onClick: Re,\n      onTouchStart: Ae,\n      onTouchMove: Xe,\n      onTouchEnd: ze,\n      tooltip: De,\n      enableTouchCrosshair: io,\n      debug: Ve\n    }, \"mesh\")), X(b, {\n      defs: Oo,\n      width: ho,\n      height: fo,\n      margin: so,\n      role: no,\n      children: h.map(function (o, i) {\n        return \"function\" == typeof o ? X(r, {\n          children: o(Q({}, e, {\n            innerWidth: co,\n            innerHeight: uo,\n            series: xo,\n            slices: Mo,\n            points: Co,\n            xScale: bo,\n            yScale: So,\n            lineGenerator: go,\n            areaGenerator: yo,\n            currentPoint: Wo,\n            setCurrentPoint: Eo,\n            currentSlice: Go,\n            setCurrentSlice: Po\n          }))\n        }, i) : Fo[o];\n      })\n    });\n  }),\n  pe = function (e) {\n    return X(S, {\n      children: function (o) {\n        var i = o.width,\n          t = o.height;\n        return X(ve, Q({\n          width: i,\n          height: t\n        }, e));\n      }\n    });\n  },\n  me = m(function (e) {\n    var o = l(null),\n      r = e.width,\n      a = e.height,\n      c = e.margin,\n      u = e.pixelRatio,\n      h = void 0 === u ? \"undefined\" != typeof window && window.devicePixelRatio || 1 : u,\n      f = e.data,\n      v = e.xScale,\n      p = void 0 === v ? {\n        type: \"point\"\n      } : v,\n      m = e.xFormat,\n      y = e.yScale,\n      x = void 0 === y ? {\n        type: \"linear\",\n        min: 0,\n        max: \"auto\"\n      } : y,\n      b = e.yFormat,\n      S = e.curve,\n      w = void 0 === S ? \"linear\" : S,\n      T = e.layers,\n      k = void 0 === T ? [\"grid\", \"markers\", \"axes\", \"areas\", \"crosshair\", \"lines\", \"points\", \"slices\", \"mesh\", \"legends\"] : T,\n      B = e.colors,\n      L = void 0 === B ? {\n        scheme: \"nivo\"\n      } : B,\n      P = e.lineWidth,\n      F = void 0 === P ? 2 : P,\n      O = e.enableArea,\n      I = void 0 !== O && O,\n      H = e.areaBaselineValue,\n      Y = void 0 === H ? 0 : H,\n      R = e.areaOpacity,\n      A = void 0 === R ? .2 : R,\n      z = e.enablePoints,\n      j = void 0 === z || z,\n      D = e.pointSize,\n      q = void 0 === D ? 6 : D,\n      Z = e.pointColor,\n      $ = void 0 === Z ? {\n        from: \"color\"\n      } : Z,\n      _ = e.pointBorderWidth,\n      ee = void 0 === _ ? 0 : _,\n      oe = e.pointBorderColor,\n      ie = void 0 === oe ? {\n        theme: \"background\"\n      } : oe,\n      te = e.enableGridX,\n      ne = void 0 === te || te,\n      ae = e.gridXValues,\n      le = e.enableGridY,\n      se = void 0 === le || le,\n      de = e.gridYValues,\n      ce = e.axisTop,\n      ue = e.axisRight,\n      he = e.axisBottom,\n      fe = void 0 === he ? {} : he,\n      ve = e.axisLeft,\n      pe = void 0 === ve ? {} : ve,\n      me = e.legends,\n      ge = void 0 === me ? [] : me,\n      ye = e.isInteractive,\n      xe = void 0 === ye || ye,\n      be = e.debugMesh,\n      Se = void 0 !== be && be,\n      Me = e.onMouseLeave,\n      Ce = e.onClick,\n      we = e.tooltip,\n      Te = void 0 === we ? U : we,\n      ke = e.canvasRef,\n      Be = g(r, a, c),\n      We = Be.margin,\n      Ee = Be.innerWidth,\n      Le = Be.innerHeight,\n      Ge = Be.outerWidth,\n      Pe = Be.outerHeight,\n      Fe = d(),\n      Oe = i(null),\n      Ve = Oe[0],\n      Ie = Oe[1],\n      He = re({\n        data: f,\n        xScale: p,\n        xFormat: m,\n        yScale: x,\n        yFormat: b,\n        width: Ee,\n        height: Le,\n        colors: L,\n        curve: w,\n        areaBaselineValue: Y,\n        pointColor: $,\n        pointBorderColor: ie\n      }),\n      Ye = He.lineGenerator,\n      Re = He.areaGenerator,\n      Ae = He.series,\n      Xe = He.xScale,\n      ze = He.yScale,\n      je = He.points,\n      De = J({\n        points: je,\n        width: Ee,\n        height: Le,\n        debug: Se\n      }),\n      qe = De.delaunay,\n      Je = De.voronoi;\n    s(function () {\n      ke && (ke.current = o.current), o.current.width = Ge * h, o.current.height = Pe * h;\n      var e = o.current.getContext(\"2d\");\n      e.scale(h, h), e.fillStyle = Fe.background, e.fillRect(0, 0, Ge, Pe), e.translate(We.left, We.top), k.forEach(function (o) {\n        if (\"function\" == typeof o && o({\n          ctx: e,\n          innerWidth: Ee,\n          innerHeight: Le,\n          series: Ae,\n          points: je,\n          xScale: Xe,\n          yScale: ze,\n          lineWidth: F,\n          lineGenerator: Ye,\n          areaGenerator: Re,\n          currentPoint: Ve,\n          setCurrentPoint: Ie\n        }), \"grid\" === o && Fe.grid.line.strokeWidth > 0 && (e.lineWidth = Fe.grid.line.strokeWidth, e.strokeStyle = Fe.grid.line.stroke, ne && W(e, {\n          width: Ee,\n          height: Le,\n          scale: Xe,\n          axis: \"x\",\n          values: ae\n        }), se && W(e, {\n          width: Ee,\n          height: Le,\n          scale: ze,\n          axis: \"y\",\n          values: de\n        })), \"axes\" === o && E(e, {\n          xScale: Xe,\n          yScale: ze,\n          width: Ee,\n          height: Le,\n          top: ce,\n          right: ue,\n          bottom: fe,\n          left: pe,\n          theme: Fe\n        }), \"areas\" === o && !0 === I) {\n          e.save(), e.globalAlpha = A, Re.context(e);\n          for (var i = Ae.length - 1; i >= 0; i--) e.fillStyle = Ae[i].color, e.beginPath(), Re(Ae[i].data.map(function (e) {\n            return e.position;\n          })), e.fill();\n          e.restore();\n        }\n        if (\"lines\" === o && (Ye.context(e), Ae.forEach(function (o) {\n          e.strokeStyle = o.color, e.lineWidth = F, e.beginPath(), Ye(o.data.map(function (e) {\n            return e.position;\n          })), e.stroke();\n        })), \"points\" === o && !0 === j && q > 0 && je.forEach(function (o) {\n          e.fillStyle = o.color, e.beginPath(), e.arc(o.x, o.y, q / 2, 0, 2 * Math.PI), e.fill(), ee > 0 && (e.strokeStyle = o.borderColor, e.lineWidth = ee, e.stroke());\n        }), \"mesh\" === o && !0 === Se && (K(e, Je), Ve && N(e, Je, Ve.index)), \"legends\" === o) {\n          var t = Ae.map(function (e) {\n            return {\n              id: e.id,\n              label: e.id,\n              color: e.color\n            };\n          }).reverse();\n          ge.forEach(function (o) {\n            G(e, Q({}, o, {\n              data: o.data || t,\n              containerWidth: Ee,\n              containerHeight: Le,\n              theme: Fe\n            }));\n          });\n        }\n      });\n    }, [o, Ge, Pe, k, Fe, Ye, Ae, Xe, ze, ne, ae, se, de, ce, ue, fe, pe, ge, je, j, q, Ve]);\n    var Ke = t(function (e) {\n        var i = M(o.current, e),\n          t = i[0],\n          n = i[1];\n        if (!C(We.left, We.top, Ee, Le, t, n)) return null;\n        var r = qe.find(t - We.left, n - We.top);\n        return je[r];\n      }, [o, We, Ee, Le, qe]),\n      Ne = V(),\n      Qe = Ne.showTooltipFromEvent,\n      Ue = Ne.hideTooltip,\n      Ze = t(function (e) {\n        var o = Ke(e);\n        Ie(o), o ? Qe(n(Te, {\n          point: o\n        }), e) : Ue();\n      }, [Ke, Ie, Qe, Ue, Te]),\n      $e = t(function (e) {\n        Ue(), Ie(null), Ve && Me && Me(Ve, e);\n      }, [Ue, Ie, Me]),\n      _e = t(function (e) {\n        if (Ce) {\n          var o = Ke(e);\n          o && Ce(o, e);\n        }\n      }, [Ke, Ce]);\n    return X(\"canvas\", {\n      ref: o,\n      width: Ge * h,\n      height: Pe * h,\n      style: {\n        width: Ge,\n        height: Pe,\n        cursor: xe ? \"auto\" : \"normal\"\n      },\n      onMouseEnter: xe ? Ze : void 0,\n      onMouseMove: xe ? Ze : void 0,\n      onMouseLeave: xe ? $e : void 0,\n      onClick: xe ? _e : void 0\n    });\n  }),\n  ge = a(function (e, o) {\n    return X(me, Q({}, e, {\n      canvasRef: o\n    }));\n  }),\n  ye = a(function (e, o) {\n    return X(S, {\n      children: function (i) {\n        var t = i.width,\n          n = i.height;\n        return X(ge, Q({\n          width: t,\n          height: n\n        }, e, {\n          ref: o\n        }));\n      }\n    });\n  });\nexport { ne as LINE_UNIQUE_ID_PREFIX, ve as Line, ge as LineCanvas, ee as LineCanvasDefaultProps, _ as LineDefaultProps, pe as ResponsiveLine, ye as ResponsiveLineCanvas, ie as useAreaGenerator, re as useLine, oe as useLineGenerator, te as useSlices };","map":{"version":3,"names":["U","e","o","point","X","P","id","z","children","data","xFormatted","yFormatted","enableChip","color","serieColor","Z","slice","i","axis","t","d","n","F","rows","points","map","O","style","tooltip","chip","serieId","tableCellValue","$","curve","xScale","type","yScale","min","max","layers","axisBottom","axisLeft","enableGridX","enableGridY","enablePoints","pointSize","pointColor","from","pointBorderWidth","pointBorderColor","theme","enablePointLabel","pointLabel","colors","scheme","enableArea","areaBaselineValue","areaOpacity","areaBlendMode","lineWidth","legends","isInteractive","enableSlices","debugSlices","sliceTooltip","debugMesh","enableCrosshair","crosshairType","_","Q","useMesh","enableTouchCrosshair","animate","motionConfig","defs","fill","role","initialHiddenIds","ee","pixelRatio","window","devicePixelRatio","oe","useLineGenerator","H","defined","x","y","c","ie","useAreaGenerator","Y","y1","y0","te","useSlices","componentId","r","width","a","height","Map","forEach","has","get","push","set","Array","entries","sort","l","s","u","x0","reverse","ne","re","useLine","xFormat","h","yFormat","f","v","p","m","g","b","S","M","C","k","B","W","enableSlicesTooltip","E","L","G","A","w","V","I","T","j","R","filter","indexOf","D","q","J","series","K","label","find","Boolean","legendData","hidden","N","concat","getPointColor","getPointBorderColor","formatX","formatY","reduce","position","index","length","borderColor","toggleSerie","lineGenerator","areaGenerator","getColor","slices","ae","AreaPath","path","config","immediate","fillOpacity","strokeWidth","mixBlendMode","le","lines","se","thickness","stroke","de","ce","debug","isCurrent","setCurrent","onMouseEnter","onMouseMove","onMouseLeave","onClick","onTouchStart","onTouchMove","onTouchEnd","showTooltipFromEvent","hideTooltip","touches","document","elementFromPoint","clientX","clientY","getAttribute","strokeOpacity","ue","current","he","symbol","size","borderWidth","enableLabel","labelYOffset","datum","fe","margin","showTooltipAt","left","top","nodes","ve","axisTop","axisRight","gridXValues","gridYValues","pointSymbol","pe","me","ge","ye","xe","be","Se","Me","pointLabelYOffset","Ce","we","Te","ke","Be","markers","We","Ee","Le","Ge","Pe","Fe","Oe","Ve","Ie","He","Ye","Re","Ae","Xe","ze","je","De","qe","Je","Ke","Ne","Qe","Ue","Ze","$e","_e","eo","oo","io","to","no","ro","ao","lo","so","co","innerWidth","uo","innerHeight","ho","outerWidth","fo","outerHeight","vo","po","mo","go","yo","xo","bo","So","Mo","Co","wo","To","ko","Bo","Wo","Eo","Lo","Go","Po","Fo","grid","xValues","yValues","axes","right","bottom","areas","crosshair","mesh","containerWidth","containerHeight","Oo","currentPoint","setCurrentPoint","currentSlice","setCurrentSlice","ResponsiveLine","canvasRef","delaunay","voronoi","getContext","scale","fillStyle","background","fillRect","translate","ctx","line","strokeStyle","values","save","globalAlpha","context","beginPath","restore","arc","Math","PI","ref","cursor","LINE_UNIQUE_ID_PREFIX","Line","LineCanvas","LineCanvasDefaultProps","LineDefaultProps","ResponsiveLineCanvas"],"sources":["C:\\Users\\Decartes\\Documents\\GitHub\\AircraftHealthML\\aircraft_health\\aircraft_health\\monitoring\\frontend\\node_modules\\@nivo\\line\\src\\PointTooltip.js","C:\\Users\\Decartes\\Documents\\GitHub\\AircraftHealthML\\aircraft_health\\aircraft_health\\monitoring\\frontend\\node_modules\\@nivo\\line\\src\\SliceTooltip.js","C:\\Users\\Decartes\\Documents\\GitHub\\AircraftHealthML\\aircraft_health\\aircraft_health\\monitoring\\frontend\\node_modules\\@nivo\\line\\src\\props.js","C:\\Users\\Decartes\\Documents\\GitHub\\AircraftHealthML\\aircraft_health\\aircraft_health\\monitoring\\frontend\\node_modules\\@nivo\\line\\src\\hooks.js","C:\\Users\\Decartes\\Documents\\GitHub\\AircraftHealthML\\aircraft_health\\aircraft_health\\monitoring\\frontend\\node_modules\\@nivo\\line\\src\\Areas.js","C:\\Users\\Decartes\\Documents\\GitHub\\AircraftHealthML\\aircraft_health\\aircraft_health\\monitoring\\frontend\\node_modules\\@nivo\\line\\src\\LinesItem.js","C:\\Users\\Decartes\\Documents\\GitHub\\AircraftHealthML\\aircraft_health\\aircraft_health\\monitoring\\frontend\\node_modules\\@nivo\\line\\src\\Lines.js","C:\\Users\\Decartes\\Documents\\GitHub\\AircraftHealthML\\aircraft_health\\aircraft_health\\monitoring\\frontend\\node_modules\\@nivo\\line\\src\\SlicesItem.js","C:\\Users\\Decartes\\Documents\\GitHub\\AircraftHealthML\\aircraft_health\\aircraft_health\\monitoring\\frontend\\node_modules\\@nivo\\line\\src\\Slices.js","C:\\Users\\Decartes\\Documents\\GitHub\\AircraftHealthML\\aircraft_health\\aircraft_health\\monitoring\\frontend\\node_modules\\@nivo\\line\\src\\Points.js","C:\\Users\\Decartes\\Documents\\GitHub\\AircraftHealthML\\aircraft_health\\aircraft_health\\monitoring\\frontend\\node_modules\\@nivo\\line\\src\\Mesh.js","C:\\Users\\Decartes\\Documents\\GitHub\\AircraftHealthML\\aircraft_health\\aircraft_health\\monitoring\\frontend\\node_modules\\@nivo\\line\\src\\Line.js","C:\\Users\\Decartes\\Documents\\GitHub\\AircraftHealthML\\aircraft_health\\aircraft_health\\monitoring\\frontend\\node_modules\\@nivo\\line\\src\\ResponsiveLine.js","C:\\Users\\Decartes\\Documents\\GitHub\\AircraftHealthML\\aircraft_health\\aircraft_health\\monitoring\\frontend\\node_modules\\@nivo\\line\\src\\LineCanvas.js","C:\\Users\\Decartes\\Documents\\GitHub\\AircraftHealthML\\aircraft_health\\aircraft_health\\monitoring\\frontend\\node_modules\\@nivo\\line\\src\\ResponsiveLineCanvas.js"],"sourcesContent":["import { memo } from 'react'\nimport { BasicTooltip } from '@nivo/tooltip'\n\nconst LinePointTooltip = ({ point }) => {\n    return (\n        <BasicTooltip\n            id={\n                <span>\n                    x: <strong>{point.data.xFormatted}</strong>, y:{' '}\n                    <strong>{point.data.yFormatted}</strong>\n                </span>\n            }\n            enableChip={true}\n            color={point.serieColor}\n        />\n    )\n}\n\nexport default memo(LinePointTooltip)\n","import { memo } from 'react'\nimport { useTheme } from '@nivo/core'\nimport { Chip, TableTooltip } from '@nivo/tooltip'\n\nconst SliceTooltip = ({ slice, axis }) => {\n    const theme = useTheme()\n    const otherAxis = axis === 'x' ? 'y' : 'x'\n\n    return (\n        <TableTooltip\n            rows={slice.points.map(point => [\n                <Chip key=\"chip\" color={point.serieColor} style={theme.tooltip.chip} />,\n                point.serieId,\n                <span key=\"value\" style={theme.tooltip.tableCellValue}>\n                    {point.data[`${otherAxis}Formatted`]}\n                </span>,\n            ])}\n        />\n    )\n}\n\nexport default memo(SliceTooltip)\n","import PointTooltip from './PointTooltip'\nimport SliceTooltip from './SliceTooltip'\n\nconst commonDefaultProps = {\n    curve: 'linear',\n\n    xScale: {\n        type: 'point',\n    },\n    yScale: {\n        type: 'linear',\n        min: 0,\n        max: 'auto',\n    },\n\n    layers: [\n        'grid',\n        'markers',\n        'axes',\n        'areas',\n        'crosshair',\n        'lines',\n        'points',\n        'slices',\n        'mesh',\n        'legends',\n    ],\n    axisBottom: {},\n    axisLeft: {},\n    enableGridX: true,\n    enableGridY: true,\n\n    enablePoints: true,\n    pointSize: 6,\n    pointColor: { from: 'color' },\n    pointBorderWidth: 0,\n    pointBorderColor: { theme: 'background' },\n    enablePointLabel: false,\n    pointLabel: 'yFormatted',\n\n    colors: { scheme: 'nivo' },\n    enableArea: false,\n    areaBaselineValue: 0,\n    areaOpacity: 0.2,\n    areaBlendMode: 'normal',\n    lineWidth: 2,\n\n    legends: [],\n\n    isInteractive: true,\n    tooltip: PointTooltip,\n    enableSlices: false,\n    debugSlices: false,\n    sliceTooltip: SliceTooltip,\n    debugMesh: false,\n    enableCrosshair: true,\n    crosshairType: 'bottom-left',\n}\n\nexport const LineDefaultProps = {\n    ...commonDefaultProps,\n    enablePointLabel: false,\n    useMesh: false,\n    enableTouchCrosshair: false,\n    animate: true,\n    motionConfig: 'gentle',\n    defs: [],\n    fill: [],\n    role: 'img',\n    initialHiddenIds: [],\n}\n\nexport const LineCanvasDefaultProps = {\n    ...commonDefaultProps,\n    pixelRatio: typeof window !== 'undefined' ? window.devicePixelRatio || 1 : 1,\n}\n","import { useCallback, useMemo, useState } from 'react'\nimport { area, line } from 'd3-shape'\nimport { curveFromProp, useTheme, useValueFormatter } from '@nivo/core'\nimport { useOrdinalColorScale, useInheritedColor } from '@nivo/colors'\nimport { computeXYScalesForSeries } from '@nivo/scales'\nimport uniqueId from 'lodash/uniqueId'\nimport { LineDefaultProps } from './props'\n\nexport const useLineGenerator = ({ curve }) => {\n    return useMemo(\n        () =>\n            line()\n                .defined(d => d.x !== null && d.y !== null)\n                .x(d => d.x)\n                .y(d => d.y)\n                .curve(curveFromProp(curve)),\n        [curve]\n    )\n}\n\nexport const useAreaGenerator = ({ curve, yScale, areaBaselineValue }) => {\n    return useMemo(() => {\n        return area()\n            .defined(d => d.x !== null && d.y !== null)\n            .x(d => d.x)\n            .y1(d => d.y)\n            .curve(curveFromProp(curve))\n            .y0(yScale(areaBaselineValue))\n    }, [curve, yScale, areaBaselineValue])\n}\n\nconst usePoints = ({ series, getPointColor, getPointBorderColor, formatX, formatY }) => {\n    return useMemo(() => {\n        return series.reduce((acc, serie) => {\n            return [\n                ...acc,\n                ...serie.data\n                    .filter(datum => datum.position.x !== null && datum.position.y !== null)\n                    .map((datum, i) => {\n                        const point = {\n                            id: `${serie.id}.${i}`,\n                            index: acc.length + i,\n                            serieId: serie.id,\n                            serieColor: serie.color,\n                            x: datum.position.x,\n                            y: datum.position.y,\n                        }\n                        point.color = getPointColor(serie)\n                        point.borderColor = getPointBorderColor(point)\n                        point.data = {\n                            ...datum.data,\n                            xFormatted: formatX(datum.data.x),\n                            yFormatted: formatY(datum.data.y),\n                        }\n\n                        return point\n                    }),\n            ]\n        }, [])\n    }, [series, getPointColor, getPointBorderColor, formatX, formatY])\n}\n\nexport const useSlices = ({ componentId, enableSlices, points, width, height }) => {\n    return useMemo(() => {\n        if (enableSlices === false) return []\n\n        if (enableSlices === 'x') {\n            const map = new Map()\n            points.forEach(point => {\n                if (point.data.x === null || point.data.y === null) return\n                if (!map.has(point.x)) map.set(point.x, [point])\n                else map.get(point.x).push(point)\n            })\n            return Array.from(map.entries())\n                .sort((a, b) => a[0] - b[0])\n                .map(([x, slicePoints], i, slices) => {\n                    const prevSlice = slices[i - 1]\n                    const nextSlice = slices[i + 1]\n\n                    let x0\n                    if (!prevSlice) x0 = x\n                    else x0 = x - (x - prevSlice[0]) / 2\n\n                    let sliceWidth\n                    if (!nextSlice) sliceWidth = width - x0\n                    else sliceWidth = x - x0 + (nextSlice[0] - x) / 2\n\n                    return {\n                        id: `slice:${componentId}:${x}`,\n                        x0,\n                        x,\n                        y0: 0,\n                        y: 0,\n                        width: sliceWidth,\n                        height,\n                        points: slicePoints.reverse(),\n                    }\n                })\n        } else if (enableSlices === 'y') {\n            const map = new Map()\n            points.forEach(point => {\n                if (point.data.x === null || point.data.y === null) return\n                if (!map.has(point.y)) map.set(point.y, [point])\n                else map.get(point.y).push(point)\n            })\n            return Array.from(map.entries())\n                .sort((a, b) => a[0] - b[0])\n                .map(([y, slicePoints], i, slices) => {\n                    const prevSlice = slices[i - 1]\n                    const nextSlice = slices[i + 1]\n\n                    let y0\n                    if (!prevSlice) y0 = y\n                    else y0 = y - (y - prevSlice[0]) / 2\n\n                    let sliceHeight\n                    if (!nextSlice) sliceHeight = height - y0\n                    else sliceHeight = y - y0 + (nextSlice[0] - y) / 2\n\n                    return {\n                        id: y,\n                        x0: 0,\n                        x: 0,\n                        y0,\n                        y,\n                        width,\n                        height: sliceHeight,\n                        points: slicePoints.reverse(),\n                    }\n                })\n        }\n    }, [componentId, enableSlices, height, points, width])\n}\n\nexport const LINE_UNIQUE_ID_PREFIX = 'line'\n\nexport const useLine = ({\n    data,\n    xScale: xScaleSpec = LineDefaultProps.xScale,\n    xFormat,\n    yScale: yScaleSpec = LineDefaultProps.yScale,\n    yFormat,\n    width,\n    height,\n    colors = LineDefaultProps.colors,\n    curve = LineDefaultProps.curve,\n    areaBaselineValue = LineDefaultProps.areaBaselineValue,\n    pointColor = LineDefaultProps.pointColor,\n    pointBorderColor = LineDefaultProps.pointBorderColor,\n    enableSlices = LineDefaultProps.enableSlicesTooltip,\n    initialHiddenIds = LineDefaultProps.initialHiddenIds,\n}) => {\n    const [componentId] = useState(uniqueId(LINE_UNIQUE_ID_PREFIX))\n    const formatX = useValueFormatter(xFormat)\n    const formatY = useValueFormatter(yFormat)\n    const getColor = useOrdinalColorScale(colors, 'id')\n    const theme = useTheme()\n    const getPointColor = useInheritedColor(pointColor, theme)\n    const getPointBorderColor = useInheritedColor(pointBorderColor, theme)\n    const [hiddenIds, setHiddenIds] = useState(initialHiddenIds ?? [])\n\n    const {\n        xScale,\n        yScale,\n        series: rawSeries,\n    } = useMemo(\n        () =>\n            computeXYScalesForSeries(\n                data.filter(item => hiddenIds.indexOf(item.id) === -1),\n                xScaleSpec,\n                yScaleSpec,\n                width,\n                height\n            ),\n        [data, hiddenIds, xScaleSpec, yScaleSpec, width, height]\n    )\n\n    const { legendData, series } = useMemo(() => {\n        const dataWithColor = data.map(line => ({\n            id: line.id,\n            label: line.id,\n            color: getColor(line),\n        }))\n        const series = dataWithColor\n            .map(datum => ({\n                ...rawSeries.find(serie => serie.id === datum.id),\n                color: datum.color,\n            }))\n            .filter(item => Boolean(item.id))\n        const legendData = dataWithColor\n            .map(item => ({ ...item, hidden: !series.find(serie => serie.id === item.id) }))\n            .reverse()\n\n        return { legendData, series }\n    }, [data, rawSeries, getColor])\n\n    const toggleSerie = useCallback(id => {\n        setHiddenIds(state =>\n            state.indexOf(id) > -1 ? state.filter(item => item !== id) : [...state, id]\n        )\n    }, [])\n\n    const points = usePoints({\n        series,\n        getPointColor,\n        getPointBorderColor,\n        formatX,\n        formatY,\n    })\n\n    const slices = useSlices({\n        componentId,\n        enableSlices,\n        points,\n        width,\n        height,\n    })\n\n    const lineGenerator = useLineGenerator({ curve })\n    const areaGenerator = useAreaGenerator({\n        curve,\n        yScale,\n        areaBaselineValue,\n    })\n\n    return {\n        legendData,\n        toggleSerie,\n        lineGenerator,\n        areaGenerator,\n        getColor,\n        series,\n        xScale,\n        yScale,\n        slices,\n        points,\n    }\n}\n","import { memo } from 'react'\nimport { useSpring, animated } from '@react-spring/web'\nimport { useAnimatedPath, useMotionConfig } from '@nivo/core'\n\nconst AreaPath = ({ areaBlendMode, areaOpacity, color, fill, path }) => {\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const animatedPath = useAnimatedPath(path)\n    const animatedProps = useSpring({\n        color,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return (\n        <animated.path\n            d={animatedPath}\n            fill={fill ? fill : animatedProps.color}\n            fillOpacity={areaOpacity}\n            strokeWidth={0}\n            style={{\n                mixBlendMode: areaBlendMode,\n            }}\n        />\n    )\n}\n\nconst Areas = ({ areaGenerator, areaOpacity, areaBlendMode, lines }) => {\n    const computedLines = lines.slice(0).reverse()\n\n    return (\n        <g>\n            {computedLines.map(line => (\n                <AreaPath\n                    key={line.id}\n                    path={areaGenerator(line.data.map(d => d.position))}\n                    {...{ areaOpacity, areaBlendMode, ...line }}\n                />\n            ))}\n        </g>\n    )\n}\n\nexport default memo(Areas)\n","import { memo, useMemo } from 'react'\nimport { animated } from '@react-spring/web'\nimport { useAnimatedPath } from '@nivo/core'\n\nconst LinesItem = ({ lineGenerator, points, color, thickness }) => {\n    const path = useMemo(() => lineGenerator(points), [lineGenerator, points])\n    const animatedPath = useAnimatedPath(path)\n\n    return <animated.path d={animatedPath} fill=\"none\" strokeWidth={thickness} stroke={color} />\n}\n\nexport default memo(LinesItem)\n","import { memo } from 'react'\nimport LinesItem from './LinesItem'\n\nconst Lines = ({ lines, lineGenerator, lineWidth }) => {\n    return lines\n        .slice(0)\n        .reverse()\n        .map(({ id, data, color }) => (\n            <LinesItem\n                key={id}\n                id={id}\n                points={data.map(d => d.position)}\n                lineGenerator={lineGenerator}\n                color={color}\n                thickness={lineWidth}\n            />\n        ))\n}\n\nexport default memo(Lines)\n","import { createElement, memo, useCallback } from 'react'\nimport { useTooltip } from '@nivo/tooltip'\n\nconst SlicesItem = ({\n    slice,\n    slices,\n    axis,\n    debug,\n    tooltip,\n    isCurrent,\n    setCurrent,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onClick,\n    onTouchStart,\n    onTouchMove,\n    onTouchEnd,\n}) => {\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n\n    const handleMouseEnter = useCallback(\n        event => {\n            showTooltipFromEvent(createElement(tooltip, { slice, axis }), event, 'right')\n            setCurrent(slice)\n            onMouseEnter && onMouseEnter(slice, event)\n        },\n        [showTooltipFromEvent, tooltip, slice, axis, setCurrent, onMouseEnter]\n    )\n\n    const handleMouseMove = useCallback(\n        event => {\n            showTooltipFromEvent(createElement(tooltip, { slice, axis }), event, 'right')\n            onMouseMove && onMouseMove(slice, event)\n        },\n        [showTooltipFromEvent, tooltip, slice, axis, onMouseMove]\n    )\n\n    const handleMouseLeave = useCallback(\n        event => {\n            hideTooltip()\n            setCurrent(null)\n            onMouseLeave && onMouseLeave(slice, event)\n        },\n        [hideTooltip, setCurrent, onMouseLeave, slice]\n    )\n\n    const handleClick = useCallback(\n        event => {\n            onClick && onClick(slice, event)\n        },\n        [slice, onClick]\n    )\n\n    const handeOnTouchStart = useCallback(\n        event => {\n            showTooltipFromEvent(createElement(tooltip, { slice, axis }), event, 'right')\n            setCurrent(slice)\n            onTouchStart && onTouchStart(slice, event)\n        },\n        [axis, onTouchStart, setCurrent, showTooltipFromEvent, slice, tooltip]\n    )\n\n    const handeOnTouchMove = useCallback(\n        event => {\n            // This event will be locked to the element that was touched originally\n            // We find the element that is currently being \"hovered over\" by getting the element at the touch point\n            const touchPoint = event.touches[0]\n            const touchingElement = document.elementFromPoint(\n                touchPoint.clientX,\n                touchPoint.clientY\n            )\n            // Is this a nivo ref?\n            const touchingSliceId = touchingElement?.getAttribute('data-ref')\n            if (touchingSliceId) {\n                // Is this a slice for this graph?\n                const slice = slices.find(slice => slice.id === touchingSliceId)\n                if (slice) {\n                    showTooltipFromEvent(createElement(tooltip, { slice, axis }), event, 'right')\n                    setCurrent(slice)\n                }\n            }\n\n            // Note here, this will pass the original slice, not the one we found\n            // But this can be found with document.elementFromPoint()\n            onTouchMove && onTouchMove(slice, event)\n        },\n        [axis, onTouchMove, setCurrent, showTooltipFromEvent, slice, slices, tooltip]\n    )\n\n    const handleOnTouchEnd = useCallback(\n        event => {\n            hideTooltip()\n            setCurrent(null)\n            onTouchEnd && onTouchEnd(slice, event)\n        },\n        [hideTooltip, setCurrent, onTouchEnd, slice]\n    )\n\n    return (\n        <rect\n            x={slice.x0}\n            y={slice.y0}\n            width={slice.width}\n            height={slice.height}\n            stroke=\"red\"\n            strokeWidth={debug ? 1 : 0}\n            strokeOpacity={0.75}\n            fill=\"red\"\n            fillOpacity={isCurrent && debug ? 0.35 : 0}\n            onMouseEnter={handleMouseEnter}\n            onMouseMove={handleMouseMove}\n            onMouseLeave={handleMouseLeave}\n            onClick={handleClick}\n            onTouchStart={handeOnTouchStart}\n            onTouchMove={handeOnTouchMove}\n            onTouchEnd={handleOnTouchEnd}\n            data-ref={slice.id}\n        />\n    )\n}\n\nexport default memo(SlicesItem)\n","import { memo } from 'react'\nimport SlicesItem from './SlicesItem'\n\nconst Slices = ({\n    slices,\n    axis,\n    debug,\n    height,\n    tooltip,\n    current,\n    setCurrent,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onClick,\n    onTouchStart,\n    onTouchMove,\n    onTouchEnd,\n}) => {\n    return slices.map(slice => (\n        <SlicesItem\n            key={slice.id}\n            slice={slice}\n            slices={slices}\n            axis={axis}\n            debug={debug}\n            height={height}\n            tooltip={tooltip}\n            setCurrent={setCurrent}\n            isCurrent={current !== null && current.id === slice.id}\n            onMouseEnter={onMouseEnter}\n            onMouseMove={onMouseMove}\n            onMouseLeave={onMouseLeave}\n            onClick={onClick}\n            onTouchStart={onTouchStart}\n            onTouchMove={onTouchMove}\n            onTouchEnd={onTouchEnd}\n        />\n    ))\n}\n\nexport default memo(Slices)\n","import { memo } from 'react'\nimport { getLabelGenerator, DotsItem, useTheme } from '@nivo/core'\n\nconst Points = ({ points, symbol, size, borderWidth, enableLabel, label, labelYOffset }) => {\n    const theme = useTheme()\n    const getLabel = getLabelGenerator(label)\n\n    /**\n     * We reverse the `points` array so that points from the lower lines in stacked lines\n     * graph are drawn on top. See https://github.com/plouc/nivo/issues/1051.\n     */\n    const mappedPoints = points\n        .slice(0)\n        .reverse()\n        .map(point => {\n            const mappedPoint = {\n                id: point.id,\n                x: point.x,\n                y: point.y,\n                datum: point.data,\n                fill: point.color,\n                stroke: point.borderColor,\n                label: enableLabel ? getLabel(point) : null,\n            }\n\n            return mappedPoint\n        })\n\n    return (\n        <g>\n            {mappedPoints.map(point => (\n                <DotsItem\n                    key={point.id}\n                    x={point.x}\n                    y={point.y}\n                    datum={point.datum}\n                    symbol={symbol}\n                    size={size}\n                    color={point.fill}\n                    borderWidth={borderWidth}\n                    borderColor={point.stroke}\n                    label={point.label}\n                    labelYOffset={labelYOffset}\n                    theme={theme}\n                />\n            ))}\n        </g>\n    )\n}\n\nexport default memo(Points)\n","import { createElement, memo, useCallback } from 'react'\nimport { useTooltip } from '@nivo/tooltip'\nimport { Mesh as BaseMesh } from '@nivo/voronoi'\n\nconst Mesh = ({\n    points,\n    width,\n    height,\n    margin,\n    setCurrent,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onClick,\n    onTouchStart,\n    onTouchMove,\n    onTouchEnd,\n    tooltip,\n    debug,\n    enableTouchCrosshair,\n}) => {\n    const { showTooltipAt, hideTooltip } = useTooltip()\n\n    const handleMouseEnter = useCallback(\n        (point, event) => {\n            showTooltipAt(\n                createElement(tooltip, { point }),\n                [point.x + margin.left, point.y + margin.top],\n                'top'\n            )\n            onMouseEnter && onMouseEnter(point, event)\n        },\n        [showTooltipAt, tooltip, onMouseEnter, margin]\n    )\n\n    const handleMouseMove = useCallback(\n        (point, event) => {\n            showTooltipAt(\n                createElement(tooltip, { point }),\n                [point.x + margin.left, point.y + margin.top],\n                'top'\n            )\n            onMouseMove && onMouseMove(point, event)\n        },\n        [showTooltipAt, tooltip, margin.left, margin.top, onMouseMove]\n    )\n\n    const handleMouseLeave = useCallback(\n        (point, event) => {\n            hideTooltip()\n            onMouseLeave && onMouseLeave(point, event)\n        },\n        [hideTooltip, onMouseLeave]\n    )\n\n    const handleClick = useCallback(\n        (point, event) => {\n            onClick && onClick(point, event)\n        },\n        [onClick]\n    )\n\n    const handleTouchStart = useCallback(\n        (point, event) => {\n            showTooltipAt(\n                createElement(tooltip, { point }),\n                [point.x + margin.left, point.y + margin.top],\n                'top'\n            )\n            onTouchStart && onTouchStart(point, event)\n        },\n        [margin.left, margin.top, onTouchStart, showTooltipAt, tooltip]\n    )\n\n    const handleTouchMove = useCallback(\n        (point, event) => {\n            showTooltipAt(\n                createElement(tooltip, { point }),\n                [point.x + margin.left, point.y + margin.top],\n                'top'\n            )\n            onTouchMove && onTouchMove(point, event)\n        },\n        [margin.left, margin.top, onTouchMove, showTooltipAt, tooltip]\n    )\n\n    const handleTouchEnd = useCallback(\n        (point, event) => {\n            hideTooltip()\n            onTouchEnd && onTouchEnd(point, event)\n        },\n        [onTouchEnd, hideTooltip]\n    )\n\n    return (\n        <BaseMesh\n            nodes={points}\n            width={width}\n            height={height}\n            setCurrent={setCurrent}\n            onMouseEnter={handleMouseEnter}\n            onMouseMove={handleMouseMove}\n            onMouseLeave={handleMouseLeave}\n            onClick={handleClick}\n            onTouchStart={handleTouchStart}\n            onTouchMove={handleTouchMove}\n            onTouchEnd={handleTouchEnd}\n            enableTouchCrosshair={enableTouchCrosshair}\n            debug={debug}\n        />\n    )\n}\n\nexport default memo(Mesh)\n","import { Fragment, useState } from 'react'\nimport {\n    bindDefs,\n    withContainer,\n    useDimensions,\n    useTheme,\n    SvgWrapper,\n    CartesianMarkers,\n} from '@nivo/core'\nimport { useInheritedColor } from '@nivo/colors'\nimport { Axes, Grid } from '@nivo/axes'\nimport { BoxLegendSvg } from '@nivo/legends'\nimport { Crosshair } from '@nivo/tooltip'\nimport { useLine } from './hooks'\nimport Areas from './Areas'\nimport Lines from './Lines'\nimport Slices from './Slices'\nimport Points from './Points'\nimport Mesh from './Mesh'\nimport PointTooltip from './PointTooltip'\nimport SliceTooltip from './SliceTooltip'\n\nconst Line = props => {\n    const {\n        data,\n        xScale: xScaleSpec = { type: 'point' },\n        xFormat,\n        yScale: yScaleSpec = {\n            type: 'linear',\n            min: 0,\n            max: 'auto',\n        },\n        yFormat,\n        layers = [\n            'grid',\n            'markers',\n            'axes',\n            'areas',\n            'crosshair',\n            'lines',\n            'points',\n            'slices',\n            'mesh',\n            'legends',\n        ],\n        curve = 'linear',\n        areaBaselineValue = 0,\n\n        colors = { scheme: 'nivo' },\n\n        margin: partialMargin,\n        width,\n        height,\n\n        axisTop,\n        axisRight,\n        axisBottom = {},\n        axisLeft = {},\n        enableGridX = true,\n        enableGridY = true,\n        gridXValues,\n        gridYValues,\n\n        lineWidth = 2,\n        enableArea = false,\n        areaOpacity = 0.2,\n        areaBlendMode = 'normal',\n\n        enablePoints = true,\n        pointSymbol,\n        pointSize = 6,\n        pointColor = { from: 'color' },\n        pointBorderWidth = 0,\n        pointBorderColor = { theme: 'background' },\n        enablePointLabel = false,\n        pointLabel = 'data.yFormatted',\n        pointLabelYOffset,\n\n        defs = [],\n        fill = [],\n\n        markers,\n\n        legends = [],\n\n        isInteractive = true,\n\n        useMesh = false,\n        debugMesh = false,\n\n        onMouseEnter,\n        onMouseMove,\n        onMouseLeave,\n        onClick,\n        onTouchStart,\n        onTouchMove,\n        onTouchEnd,\n\n        tooltip = PointTooltip,\n\n        enableSlices = false,\n        debugSlices = false,\n        sliceTooltip = SliceTooltip,\n\n        enableCrosshair = true,\n        crosshairType = 'bottom-left',\n        enableTouchCrosshair = false,\n\n        role = 'img',\n        initialHiddenIds = [],\n    } = props\n\n    const { margin, innerWidth, innerHeight, outerWidth, outerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n\n    const {\n        legendData,\n        toggleSerie,\n        lineGenerator,\n        areaGenerator,\n        series,\n        xScale,\n        yScale,\n        slices,\n        points,\n    } = useLine({\n        data,\n        xScale: xScaleSpec,\n        xFormat,\n        yScale: yScaleSpec,\n        yFormat,\n        width: innerWidth,\n        height: innerHeight,\n        colors,\n        curve,\n        areaBaselineValue,\n        pointColor,\n        pointBorderColor,\n        enableSlices,\n        initialHiddenIds,\n    })\n\n    const theme = useTheme()\n    const getPointColor = useInheritedColor(pointColor, theme)\n    const getPointBorderColor = useInheritedColor(pointBorderColor, theme)\n\n    const [currentPoint, setCurrentPoint] = useState(null)\n    const [currentSlice, setCurrentSlice] = useState(null)\n\n    const layerById = {\n        grid: (\n            <Grid\n                key=\"grid\"\n                theme={theme}\n                width={innerWidth}\n                height={innerHeight}\n                xScale={enableGridX ? xScale : null}\n                yScale={enableGridY ? yScale : null}\n                xValues={gridXValues}\n                yValues={gridYValues}\n            />\n        ),\n        markers: (\n            <CartesianMarkers\n                key=\"markers\"\n                markers={markers}\n                width={innerWidth}\n                height={innerHeight}\n                xScale={xScale}\n                yScale={yScale}\n                theme={theme}\n            />\n        ),\n        axes: (\n            <Axes\n                key=\"axes\"\n                xScale={xScale}\n                yScale={yScale}\n                width={innerWidth}\n                height={innerHeight}\n                theme={theme}\n                top={axisTop}\n                right={axisRight}\n                bottom={axisBottom}\n                left={axisLeft}\n            />\n        ),\n        areas: null,\n        lines: (\n            <Lines key=\"lines\" lines={series} lineGenerator={lineGenerator} lineWidth={lineWidth} />\n        ),\n        slices: null,\n        points: null,\n        crosshair: null,\n        mesh: null,\n        legends: legends.map((legend, i) => (\n            <BoxLegendSvg\n                key={`legend.${i}`}\n                {...legend}\n                containerWidth={innerWidth}\n                containerHeight={innerHeight}\n                data={legend.data || legendData}\n                theme={theme}\n                toggleSerie={legend.toggleSerie ? toggleSerie : undefined}\n            />\n        )),\n    }\n\n    const boundDefs = bindDefs(defs, series, fill)\n\n    if (enableArea) {\n        layerById.areas = (\n            <Areas\n                key=\"areas\"\n                areaGenerator={areaGenerator}\n                areaOpacity={areaOpacity}\n                areaBlendMode={areaBlendMode}\n                lines={series}\n            />\n        )\n    }\n\n    if (isInteractive && enableSlices !== false) {\n        layerById.slices = (\n            <Slices\n                key=\"slices\"\n                slices={slices}\n                axis={enableSlices}\n                debug={debugSlices}\n                height={innerHeight}\n                tooltip={sliceTooltip}\n                current={currentSlice}\n                setCurrent={setCurrentSlice}\n                onMouseEnter={onMouseEnter}\n                onMouseMove={onMouseMove}\n                onMouseLeave={onMouseLeave}\n                onClick={onClick}\n                onTouchStart={onTouchStart}\n                onTouchMove={onTouchMove}\n                onTouchEnd={onTouchEnd}\n            />\n        )\n    }\n\n    if (enablePoints) {\n        layerById.points = (\n            <Points\n                key=\"points\"\n                points={points}\n                symbol={pointSymbol}\n                size={pointSize}\n                color={getPointColor}\n                borderWidth={pointBorderWidth}\n                borderColor={getPointBorderColor}\n                enableLabel={enablePointLabel}\n                label={pointLabel}\n                labelYOffset={pointLabelYOffset}\n            />\n        )\n    }\n\n    if (isInteractive && enableCrosshair) {\n        if (currentPoint !== null) {\n            layerById.crosshair = (\n                <Crosshair\n                    key=\"crosshair\"\n                    width={innerWidth}\n                    height={innerHeight}\n                    x={currentPoint.x}\n                    y={currentPoint.y}\n                    type={crosshairType}\n                />\n            )\n        }\n        if (currentSlice !== null) {\n            layerById.crosshair = (\n                <Crosshair\n                    key=\"crosshair\"\n                    width={innerWidth}\n                    height={innerHeight}\n                    x={currentSlice.x}\n                    y={currentSlice.y}\n                    type={enableSlices}\n                />\n            )\n        }\n    }\n\n    if (isInteractive && useMesh && enableSlices === false) {\n        layerById.mesh = (\n            <Mesh\n                key=\"mesh\"\n                points={points}\n                width={innerWidth}\n                height={innerHeight}\n                margin={margin}\n                current={currentPoint}\n                setCurrent={setCurrentPoint}\n                onMouseEnter={onMouseEnter}\n                onMouseMove={onMouseMove}\n                onMouseLeave={onMouseLeave}\n                onClick={onClick}\n                onTouchStart={onTouchStart}\n                onTouchMove={onTouchMove}\n                onTouchEnd={onTouchEnd}\n                tooltip={tooltip}\n                enableTouchCrosshair={enableTouchCrosshair}\n                debug={debugMesh}\n            />\n        )\n    }\n\n    return (\n        <SvgWrapper\n            defs={boundDefs}\n            width={outerWidth}\n            height={outerHeight}\n            margin={margin}\n            role={role}\n        >\n            {layers.map((layer, i) => {\n                if (typeof layer === 'function') {\n                    return (\n                        <Fragment key={i}>\n                            {layer({\n                                ...props,\n                                innerWidth,\n                                innerHeight,\n                                series,\n                                slices,\n                                points,\n                                xScale,\n                                yScale,\n                                lineGenerator,\n                                areaGenerator,\n                                currentPoint,\n                                setCurrentPoint,\n                                currentSlice,\n                                setCurrentSlice,\n                            })}\n                        </Fragment>\n                    )\n                }\n\n                return layerById[layer]\n            })}\n        </SvgWrapper>\n    )\n}\n\nexport default withContainer(Line)\n","import { ResponsiveWrapper } from '@nivo/core'\nimport Line from './Line'\n\nconst ResponsiveLine = props => (\n    <ResponsiveWrapper>\n        {({ width, height }) => <Line width={width} height={height} {...props} />}\n    </ResponsiveWrapper>\n)\n\nexport default ResponsiveLine\n","import { createElement, useRef, useEffect, useState, useCallback, forwardRef } from 'react'\nimport {\n    withContainer,\n    useDimensions,\n    useTheme,\n    getRelativeCursor,\n    isCursorInRect,\n} from '@nivo/core'\nimport { renderAxesToCanvas, renderGridLinesToCanvas } from '@nivo/axes'\nimport { renderLegendToCanvas } from '@nivo/legends'\nimport { useTooltip } from '@nivo/tooltip'\nimport { useVoronoiMesh, renderVoronoiToCanvas, renderVoronoiCellToCanvas } from '@nivo/voronoi'\nimport { useLine } from './hooks'\nimport PointTooltip from './PointTooltip'\n\nconst LineCanvas = props => {\n    const canvasEl = useRef(null)\n    const {\n        width,\n        height,\n        margin: partialMargin,\n        pixelRatio = typeof window !== 'undefined' ? window.devicePixelRatio || 1 : 1,\n\n        data,\n        xScale: xScaleSpec = { type: 'point' },\n        xFormat,\n        yScale: yScaleSpec = {\n            type: 'linear',\n            min: 0,\n            max: 'auto',\n        },\n        yFormat,\n        curve = 'linear',\n\n        layers = [\n            'grid',\n            'markers',\n            'axes',\n            'areas',\n            'crosshair',\n            'lines',\n            'points',\n            'slices',\n            'mesh',\n            'legends',\n        ],\n\n        colors = { scheme: 'nivo' },\n        lineWidth = 2,\n\n        enableArea = false,\n        areaBaselineValue = 0,\n        areaOpacity = 0.2,\n\n        enablePoints = true,\n        pointSize = 6,\n        pointColor = { from: 'color' },\n        pointBorderWidth = 0,\n        pointBorderColor = { theme: 'background' },\n\n        enableGridX = true,\n        gridXValues,\n        enableGridY = true,\n        gridYValues,\n        axisTop,\n        axisRight,\n        axisBottom = {},\n        axisLeft = {},\n\n        legends = [],\n\n        isInteractive = true,\n        debugMesh = false,\n        //onMouseEnter,\n        //onMouseMove,\n        onMouseLeave,\n        onClick,\n        tooltip = PointTooltip,\n        canvasRef,\n    } = props\n    const { margin, innerWidth, innerHeight, outerWidth, outerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n    const theme = useTheme()\n    const [currentPoint, setCurrentPoint] = useState(null)\n\n    const { lineGenerator, areaGenerator, series, xScale, yScale, points } = useLine({\n        data,\n        xScale: xScaleSpec,\n        xFormat,\n        yScale: yScaleSpec,\n        yFormat,\n        width: innerWidth,\n        height: innerHeight,\n        colors,\n        curve,\n        areaBaselineValue,\n        pointColor,\n        pointBorderColor,\n    })\n\n    const { delaunay, voronoi } = useVoronoiMesh({\n        points,\n        width: innerWidth,\n        height: innerHeight,\n        debug: debugMesh,\n    })\n\n    useEffect(() => {\n        if (canvasRef) {\n            canvasRef.current = canvasEl.current\n        }\n\n        canvasEl.current.width = outerWidth * pixelRatio\n        canvasEl.current.height = outerHeight * pixelRatio\n\n        const ctx = canvasEl.current.getContext('2d')\n\n        ctx.scale(pixelRatio, pixelRatio)\n\n        ctx.fillStyle = theme.background\n        ctx.fillRect(0, 0, outerWidth, outerHeight)\n        ctx.translate(margin.left, margin.top)\n\n        layers.forEach(layer => {\n            if (typeof layer === 'function') {\n                layer({\n                    ctx,\n                    innerWidth,\n                    innerHeight,\n                    series,\n                    points,\n                    xScale,\n                    yScale,\n                    lineWidth,\n                    lineGenerator,\n                    areaGenerator,\n                    currentPoint,\n                    setCurrentPoint,\n                })\n            }\n\n            if (layer === 'grid' && theme.grid.line.strokeWidth > 0) {\n                ctx.lineWidth = theme.grid.line.strokeWidth\n                ctx.strokeStyle = theme.grid.line.stroke\n\n                enableGridX &&\n                    renderGridLinesToCanvas(ctx, {\n                        width: innerWidth,\n                        height: innerHeight,\n                        scale: xScale,\n                        axis: 'x',\n                        values: gridXValues,\n                    })\n\n                enableGridY &&\n                    renderGridLinesToCanvas(ctx, {\n                        width: innerWidth,\n                        height: innerHeight,\n                        scale: yScale,\n                        axis: 'y',\n                        values: gridYValues,\n                    })\n            }\n\n            if (layer === 'axes') {\n                renderAxesToCanvas(ctx, {\n                    xScale,\n                    yScale,\n                    width: innerWidth,\n                    height: innerHeight,\n                    top: axisTop,\n                    right: axisRight,\n                    bottom: axisBottom,\n                    left: axisLeft,\n                    theme,\n                })\n            }\n\n            if (layer === 'areas' && enableArea === true) {\n                ctx.save()\n                ctx.globalAlpha = areaOpacity\n\n                areaGenerator.context(ctx)\n                for (let i = series.length - 1; i >= 0; i--) {\n                    ctx.fillStyle = series[i].color\n                    ctx.beginPath()\n                    areaGenerator(series[i].data.map(d => d.position))\n                    ctx.fill()\n                }\n\n                ctx.restore()\n            }\n\n            if (layer === 'lines') {\n                lineGenerator.context(ctx)\n                series.forEach(serie => {\n                    ctx.strokeStyle = serie.color\n                    ctx.lineWidth = lineWidth\n                    ctx.beginPath()\n                    lineGenerator(serie.data.map(d => d.position))\n                    ctx.stroke()\n                })\n            }\n\n            if (layer === 'points' && enablePoints === true && pointSize > 0) {\n                points.forEach(point => {\n                    ctx.fillStyle = point.color\n                    ctx.beginPath()\n                    ctx.arc(point.x, point.y, pointSize / 2, 0, 2 * Math.PI)\n                    ctx.fill()\n\n                    if (pointBorderWidth > 0) {\n                        ctx.strokeStyle = point.borderColor\n                        ctx.lineWidth = pointBorderWidth\n                        ctx.stroke()\n                    }\n                })\n            }\n\n            if (layer === 'mesh' && debugMesh === true) {\n                renderVoronoiToCanvas(ctx, voronoi)\n                if (currentPoint) {\n                    renderVoronoiCellToCanvas(ctx, voronoi, currentPoint.index)\n                }\n            }\n\n            if (layer === 'legends') {\n                const legendData = series\n                    .map(serie => ({\n                        id: serie.id,\n                        label: serie.id,\n                        color: serie.color,\n                    }))\n                    .reverse()\n\n                legends.forEach(legend => {\n                    renderLegendToCanvas(ctx, {\n                        ...legend,\n                        data: legend.data || legendData,\n                        containerWidth: innerWidth,\n                        containerHeight: innerHeight,\n                        theme,\n                    })\n                })\n            }\n        })\n    }, [\n        canvasEl,\n        outerWidth,\n        outerHeight,\n        layers,\n        theme,\n        lineGenerator,\n        series,\n        xScale,\n        yScale,\n        enableGridX,\n        gridXValues,\n        enableGridY,\n        gridYValues,\n        axisTop,\n        axisRight,\n        axisBottom,\n        axisLeft,\n        legends,\n        points,\n        enablePoints,\n        pointSize,\n        currentPoint,\n    ])\n\n    const getPointFromMouseEvent = useCallback(\n        event => {\n            const [x, y] = getRelativeCursor(canvasEl.current, event)\n            if (!isCursorInRect(margin.left, margin.top, innerWidth, innerHeight, x, y)) return null\n\n            const pointIndex = delaunay.find(x - margin.left, y - margin.top)\n            return points[pointIndex]\n        },\n        [canvasEl, margin, innerWidth, innerHeight, delaunay]\n    )\n\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n\n    const handleMouseHover = useCallback(\n        event => {\n            const point = getPointFromMouseEvent(event)\n            setCurrentPoint(point)\n\n            if (point) {\n                showTooltipFromEvent(createElement(tooltip, { point }), event)\n            } else {\n                hideTooltip()\n            }\n        },\n        [getPointFromMouseEvent, setCurrentPoint, showTooltipFromEvent, hideTooltip, tooltip]\n    )\n\n    const handleMouseLeave = useCallback(\n        event => {\n            hideTooltip()\n            setCurrentPoint(null)\n            currentPoint && onMouseLeave && onMouseLeave(currentPoint, event)\n        },\n        [hideTooltip, setCurrentPoint, onMouseLeave]\n    )\n\n    const handleClick = useCallback(\n        event => {\n            if (onClick) {\n                const point = getPointFromMouseEvent(event)\n                point && onClick(point, event)\n            }\n        },\n        [getPointFromMouseEvent, onClick]\n    )\n\n    return (\n        <canvas\n            ref={canvasEl}\n            width={outerWidth * pixelRatio}\n            height={outerHeight * pixelRatio}\n            style={{\n                width: outerWidth,\n                height: outerHeight,\n                cursor: isInteractive ? 'auto' : 'normal',\n            }}\n            onMouseEnter={isInteractive ? handleMouseHover : undefined}\n            onMouseMove={isInteractive ? handleMouseHover : undefined}\n            onMouseLeave={isInteractive ? handleMouseLeave : undefined}\n            onClick={isInteractive ? handleClick : undefined}\n        />\n    )\n}\n\nconst LineCanvasWithContainer = withContainer(LineCanvas)\n\nexport default forwardRef((props, ref) => <LineCanvasWithContainer {...props} canvasRef={ref} />)\n","import { forwardRef } from 'react'\nimport { ResponsiveWrapper } from '@nivo/core'\nimport LineCanvas from './LineCanvas'\n\nconst ResponsiveLineCanvas = (props, ref) => (\n    <ResponsiveWrapper>\n        {({ width, height }) => <LineCanvas width={width} height={height} {...props} ref={ref} />}\n    </ResponsiveWrapper>\n)\n\nexport default forwardRef(ResponsiveLineCanvas)\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}